#!/usr/bin/perl -w
########################################################################
# artmod
#
# Script to generate clean module source for art.
#
# Usage: artmod [<options>] <module-type> <qualified-name>
#
# <module-type> can be, "analyzer," "filter," "generator" (artdaq only),
#   or "producer."
#
# <qualified-name> is the namespace-qualified name of the module class.
#   For instance, "nova::trk::TrackAnalyzer."
#
# For detailed documentation, see the pod at the end of this file; or
# use the --help option.
#
# 2011/03/08 Chris Green for the art team.
########################################################################

####################################
# Preamble,
use strict;

use Cwd qw(chdir :DEFAULT);
use File::Basename;
use FileHandle;
use Getopt::Long;
use Pod::Usage;

Getopt::Long::Configure(qw(no_ignore_case bundling require_order));

sub class_defn($\@\@);
sub class_impl($\@\@);
sub vprint;

####################################
# Variables and defaults.
my $currtime = localtime;
my $current_filename;

my $default_boilerplate = << 'EOF';
////////////////////////////////////////////////////////////////////////
// Class:       %c
// Module Type: %t
// File:        %f
//
// Generated at %d by %U using artmod
// from %p %v.
////////////////////////////////////////////////////////////////////////
EOF

my $module_types = { analyzer => 1, filter => 1, generator => 1, producer => 1 };

my $optional_entries =
  {
   analyzer =>
   {
    beginJob => "void beginJob() override",
    beginRun => "void beginRun(art::Run const & r) override",
    beginSubRun => "void beginSubRun(art::SubRun const & sr) override",
    endJob => "void endJob() override",
    endRun => "void endRun(art::Run const & r) override",
    endSubRun => "void endSubRun(art::SubRun const & sr) override",
    reconfigure => "void reconfigure(fhicl::ParameterSet const & p) override",
    respondToCloseInputFile => "void respondToCloseInputFile(art::FileBlock const & fb) override",
    respondToCloseOutputFiles => "void respondToCloseOutputFiles(art::FileBlock const & fb) override",
    respondToOpenInputFile => "void respondToOpenInputFile(art::FileBlock const & fb) override",
    respondToOpenOutputFiles => "void respondToOpenOutputFiles(art::FileBlock const & fb) override"
   },
   filter =>
   {
    beginJob => "void beginJob() override",
    beginRun => "bool beginRun(art::Run & r) override",
    beginSubRun => "bool beginSubRun(art::SubRun & sr) override",
    endJob => "void endJob() override",
    endRun => "bool endRun(art::Run & r) override",
    endSubRun => "bool endSubRun(art::SubRun & sr) override",
    reconfigure => "void reconfigure(fhicl::ParameterSet const & p) override",
    respondToCloseInputFile => "void respondToCloseInputFile(art::FileBlock const & fb) override",
    respondToCloseOutputFiles => "void respondToCloseOutputFiles(art::FileBlock const & fb) override",
    respondToOpenInputFile => "void respondToOpenInputFile(art::FileBlock const  &fb) override",
    respondToOpenOutputFiles => "void respondToOpenOutputFiles(art::FileBlock const & fb) override"
   },
   producer =>
   {
    beginJob => "void beginJob() override",
    beginRun => "void beginRun(art::Run & r) override",
    beginSubRun => "void beginSubRun(art::SubRun & sr) override",
    endJob => "void endJob() override",
    endRun => "void endRun(art::Run & r) override",
    endSubRun => "void endSubRun(art::SubRun & sr) override",
    reconfigure => "void reconfigure(fhicl::ParameterSet const & p) override",
    respondToCloseInputFile => "void respondToCloseInputFile(art::FileBlock const & fb) override",
    respondToCloseOutputFiles => "void respondToCloseOutputFiles(art::FileBlock const & fb) override",
    respondToOpenInputFile => "void respondToOpenInputFile(art::FileBlock const & fb) override",
    respondToOpenOutputFiles => "void respondToOpenOutputFiles(art::FileBlock const & fb) override"
   }
  };

my $constructors =
  {
   analyzer =>
   {
    explicit => 1,
    args => [ "fhicl::ParameterSet const & p" ]
   },
   filter =>
   {
    explicit => 1,
    args => [ "fhicl::ParameterSet const & p" ]
   },
   generator =>
   {
    explicit => 1,
    args => [ "fhicl::ParameterSet const & p" ]
   },
   producer =>
   {
    explicit => 1,
    args => [ "fhicl::ParameterSet const & p" ]
   }
  };

my $macros =
  {
   analyzer => "DEFINE_ART_MODULE",
   filter => "DEFINE_ART_MODULE",
   generator => "DEFINE_ARTDAQ_GENERATOR",
   producer => "DEFINE_ART_MODULE",
  };

my $required_entries =
  {
   analyzer =>
   {
    analyze => "void analyze(art::Event const & e) override"
   },
   filter =>
   {
    filter => "bool filter(art::Event & e) override"
   },
   generator =>
   {
    getNext_ => "bool getNext_(FragmentPtrs & output) override"
   },
   producer =>
   {
    produce => "void produce(art::Event & e) override"
   }
  };

my $base_headers =
  {
   analyzer => "art/Framework/Core/EDAnalyzer.h",
   filter => "art/Framework/Core/EDFilter.h",
   generator => "artdaq/DAQdata/FragmentGenerator.h",
   producer => "art/Framework/Core/EDProducer.h"
  };

my $base_classes =
  {
   analyzer => "art::EDAnalyzer",
   filter => "art::EDFilter",
   generator => "artdaq::FragmentGenerator",
   producer => "art::EDProducer"
  };


my $indent = ' ' x 2;

my $options = {};

####################################
# Main code.

GetOptions($options,
           "all-entries|A",
           "boilerplate|b=s",
           "entry-list|E=s",
           "entries|entry|e=s@",
           "force|f",
           "header-loc=s",
           "guard=s",
           "help|h|?",
           "help-types",
           "impl-boilerplate=s",
           "split",
           "split-ext=s",
           "use-boost-unit|boost-unit|u",
           "verbose|v",
          ) or pod2usage(-exitval => 2);

# One option implies the other.
${options}->{split} = 1
  if (exists ${options}->{"split-ext"});

pod2usage(-exitval => 1, -verbose => 3) if $options->{help};

help_types() if ($options->{"help-types"});

# Check non-option arguments.
my ($module_type, $qual_name);
if ((scalar @ARGV) == 1) {
  my @mtypes_found = map { ($ARGV[0] =~ /\Q$_\E$/i)?$_:(); } keys %${module_types};
  if (scalar @mtypes_found == 1) {
    printf STDERR "INFO: Inferring module type $mtypes_found[0] from class name $ARGV[0].\n";
    ($module_type, $qual_name) = ($mtypes_found[0], $ARGV[0]);
  } else {
    printf STDERR "ERROR: Unable to infer module type from single argument, class name $ARGV[0], \n";
    pod2usage(-exitval => 2);
  }
} elsif ((scalar @ARGV) == 2) {
 ($module_type, $qual_name) = @ARGV;
} else {
  print STDERR "ERROR: Expected exactly two non-option arguments.\n";
  pod2usage(-exitval => 2);
}

# Process module type
if (not exists $module_types->{lc $module_type}) {
  print STDERR "ERROR: $module_type is not a recognized module type (",
    join(",", sort keys %{$module_types}), ")\n";
  exit(1);
}
$module_type = lc $module_type;

# Process name;
my @namespaces = split '::', $qual_name;
my $class_name = pop @namespaces;

# Process header location for multi
my $header_path = (exists ${options}->{"header-loc"})?
  "$options->{\"header-loc\"}/":
  "";
$header_path = "${header_path}${class_name}.h";

# Generate code.
if (exists ${options}->{split}) {
  generate_multi();
} else {
  generate_combined();
}

1;

# Print help text for available module types.
sub help_types {
  print STDERR "Available module types: ",
    join(", ", sort keys %{$module_types}), ".\n\nMore details:\n";
  foreach my $module_type (sort keys %{$module_types}) {
    print STDERR "Module Type: $module_type\n";
    print STDERR "Required members:\n",
      map({sprintf("  %s\n", $required_entries->{$module_type}->{$_});}
          sort keys %{$required_entries->{$module_type}});
    print STDERR "Optional members:\n",
      map({sprintf("  %s\n", $optional_entries->{$module_type}->{$_});}
          sort keys %{$optional_entries->{$module_type}});
    print STDERR "\n";
  }
  exit(2);
}

# Do the substitution of "%" directives in the boilerplate source.
sub ins_vals {
  my $bp = shift;
  return unless $$bp;
 WL:  while ($$bp =~ m&(.?%.)&mg) {
    my $found_exp = ${1};
    my $s = (pos $$bp) - length($found_exp);
    if (${found_exp} =~ m&^\\\%(.)$&) { # Want literal %
      my $replacement_exp = "%${1}";
      $$bp =~ s&\Q${found_exp}\E\G&${replacement_exp}&;
      pos $$bp = $s + length($replacement_exp);
    } else { # Have a %X string to substitute.
      my $wanted_data;
      my $lc = substr $found_exp, -1, 1;
    SW1: {
        $lc eq "c" and do
          { $wanted_data = $class_name; last SW1; };
        $lc eq "C" and do
          { $wanted_data = $qual_name; last SW1; };
        $lc eq "d" and do
          { $wanted_data = $currtime; last SW1; };
        $lc eq "f" and do
          { $wanted_data = basename($current_filename); last SW1; };
        $lc eq "F" and do
          { $wanted_data = $current_filename; last SW1; };
        $lc eq "n" and do
          { $wanted_data = join("::", @namespaces); last SW1; };
        $lc eq "p" and do
          { $wanted_data = '@product@'; last SW1; };
        $lc eq "t" and do
          { $wanted_data = $module_type; last SW1; };
        $lc eq "u" and do
          { $wanted_data = (getpwuid($<))[0]; last SW1; };
        $lc eq "U" and do
          { $wanted_data = (getpwuid($<))[6] ||
              (getpwuid($<))[0]; last SW1; };
        $lc eq "v" and do
          { $wanted_data = '@version@'; last SW1; };
        print STDERR "Unrecognized substitution expression, ",
          "\"%$lc\" in boilerplate: ignored.";
        next WL;
      }
      my $replacement_exp = $found_exp;
      $replacement_exp =~ s&(.?)%${lc}&${1}${wanted_data}&;
      $$bp =~ s&\Q${found_exp}\E\G&${replacement_exp}&;
      pos $$bp = $s + length($replacement_exp);
    }
  }
  # Deal with any embedded \\[UE] sets
  $$bp =~ s&\\[U](.*?)(?:\\E|$)&\U$1\E&gm;
  $$bp =~ s&\\[L](.*?)(?:\\E|$)&\L$1\E&gm;
  $$bp =~ s&\\[E]&&gm; # Deal with dangling \Es.
}

sub decl_boilerplate(\$) {
  my $h_b = shift;
  if (${options}->{boilerplate}) {
    my $f = ${options}->{boilerplate};
    $$h_b = `cat \"$f\"`;
  } elsif ($ENV{ARTMOD_BOILERPLATE}) {
    $$h_b = `cat \"$ENV{ARTMOD_BOILERPLATE}\"`;
  } else {
    $$h_b = $default_boilerplate;
  }
  ins_vals($h_b);
}

sub impl_boilerplate(\$) {
  my $i_b = shift;
  if (${options}->{"impl-boilerplate"}) {
    my $f = ${options}->{"impl-boilerplate"};
    $$i_b = `cat \"$f\"`;
  } elsif ($ENV{ARTMOD_IMPL_BOILERPLATE}) {
    $$i_b = `cat \"$ENV{ARTMOD_IMPL_BOILERPLATE}\"`;
  } elsif ($options->{split}) {
    $$i_b = $default_boilerplate;
  }
  ins_vals($i_b);
}

sub generate_multi {
  my ($h_b, $i_b);

  ####################################
  # Header
  $current_filename = sprintf("%s/${class_name}.h", getcwd());
  my $fh = new FileHandle(">${current_filename}");
  unless (defined $fh) {
    print STDERR "ERROR: unable to open \"${current_filename}\" for output.";
    exit(1);
  }

  my $header_guard = ${options}->{guard} ||
    $ENV{ARTMOD_HEADER_GUARD} ||
      $header_path;

  ins_vals(\$header_guard);

  $header_guard =~ s&(?:[/\.]|::)&_&g;

  print $fh "#ifndef $header_guard\n";
  print $fh "#define $header_guard\n";

  # Boilerplate.
  decl_boilerplate($h_b);
  print $fh $h_b, "\n";

  # Header includes.
  header_includes($fh, "class_defn");

  print $fh "\n";

  # Class declaration.
  class_decl($fh);

  print $fh "\n";

  my @optional_entries = ();
  my @unrecognized_entries = ();

  # Class definition.
  class_defn($fh, @optional_entries, @unrecognized_entries);

  print $fh "#endif /* $header_guard */\n";

  close($fh);
  print "INFO: Wrote ${current_filename}\n";

  ####################################
  # Implementation
  $current_filename = sprintf("%s/${class_name}%s",
                              getcwd(),
                              $options->{"split-ext"} || '.cxx');
  $fh = new FileHandle(">${current_filename}");
  unless (defined $fh) {
    print STDERR "ERROR: unable to open \"${current_filename}\" for output.";
    exit(1);
  }

  # Implementation includes.
  header_includes($fh, "class_impl");

  print $fh "\n\n";

  # Implementation boilerplate.
  impl_boilerplate($i_b);
  print $fh $i_b, "\n" if $i_b;

  # Class implementation.
  class_impl($fh, @optional_entries, @unrecognized_entries);

  close($fh);
  print "INFO: Wrote ${current_filename}\n";

  ####################################
  # Module registration.
  $current_filename = sprintf("%s/${class_name}_module.cc", getcwd());
  $fh = new FileHandle(">${current_filename}");
  unless (defined $fh) {
    print STDERR "ERROR: unable to open \"${current_filename}\" for output.";
    exit(1);
  }

  # Implementation includes.
  header_includes($fh, "module_reg");

  print $fh "\n\n";

  # Registration boiler plate:
  my $reg_bp = $default_boilerplate;
  ins_vals(\$reg_bp);
  print $fh $reg_bp, "\n\n";

  module_reg($fh);

  close($fh);
  print "INFO: Wrote ${current_filename}\n";
}

sub generate_combined {
  my ($h_b, $i_b);
  $current_filename = sprintf("%s/${class_name}_module.cc", getcwd());
  my $fh = new FileHandle(">${current_filename}");
  unless (defined $fh) {
    print STDERR "ERROR: unable to open \"${current_filename}\" for output.";
    exit(1);
  }

  # Boilerplate.
  decl_boilerplate($h_b);
  print $fh $h_b, "\n";

  # Header includes.
  header_includes($fh, "combined");

  print $fh "\n";

  # Class declaration.
  class_decl($fh);

  print $fh "\n";

  my @optional_entries = ();
  my @unrecognized_entries = ();

  # Class definition.
  class_defn($fh, @optional_entries, @unrecognized_entries);

  print $fh "\n\n";

  # Implementation boilerplate.
  impl_boilerplate($i_b);
  print $fh $i_b, "\n" if $i_b;

  # Class implementation.
  class_impl($fh, @optional_entries, @unrecognized_entries);

  # Module registration.
  module_reg($fh);

  # Close file.
  $fh->close();

  print "INFO: Wrote ${current_filename}\n";
}

sub header_includes {
  my $modes = { combined => 0, class_defn => 1, class_impl => 2, module_reg => 3 };
  my ($fh, $mode) = @_;
  if (not exists $modes->{$mode}) {
    print STDERR "LOGIC ERROR: unknown header_includes mode $mode.\n";
    exit 9;
  }
  my @header_lines = ();
  if ($mode eq "class_defn" or $mode eq "combined") {
    push @header_lines, sprintf("#include \"%s\"", $base_headers->{$module_type}),
  }
  if ($mode eq "class_impl" or $mode eq "combined") {
    if ($mode ne "combined") {
      push @header_lines,
        "#include \"${header_path}\"";
    }
    if ($options->{"use-boost-unit"}) {
      push @header_lines,
        "\n#include <boost/test/included/unit_test.hpp>";
    }
  }
  if ($mode eq "module_reg" or $mode eq "combined") {
    if ($mode ne "combined") {
      push @header_lines,
        "#include \"${header_path}\"";
    }
    push @header_lines, '#include "art/Framework/Core/ModuleMacros.h"';
  }
  print $fh join("\n", @header_lines), "\n";
}

sub class_decl {
  my $fh = shift;
  my $indent_level = 0;
  foreach my $ns (@namespaces) {
    print $fh $indent x $indent_level++, "namespace ${ns} {\n";
  }
  print $fh $indent x $indent_level, "class $class_name;\n";
  foreach my $ns (@namespaces) {
    print $fh $indent x --$indent_level, "}\n";
  }
}

sub class_defn($\@\@) {
  my ($fh, $optional_ep_list, $unrecognized_entries) = @_;
  my $base_class = ${base_classes}->{${module_type}};
  print $fh <<EOF;
class ${qual_name} : public ${base_class} {
public:
EOF
print $fh "${indent}",
  (${constructors}->{${module_type}}->{explicit}?"explicit ":""),
    "${class_name}(",
      join(", ", @{${constructors}->{${module_type}}->{args}}),
        ");\n";
  print $fh <<EOF;
${indent}virtual ~${class_name}();

EOF
  foreach my $req (sort keys %{${required_entries}->{${module_type}}}) {
    vprint "Adding required member function ",
      $required_entries->{${module_type}}->{${req}},
        "\n";
    print $fh "${indent}",
      $required_entries->{${module_type}}->{${req}}, ";\n";
  }

  print $fh "\n";

  my %entries_hash = ();
  my @entries = ();
  my @file_entries = ();
  if (${options}->{"entry-list"}) {
    if (-r ${options}->{"entry-list"}) {
      my $f = ${options}->{"entry-list"};
      @file_entries = `cat \"$f\"`;
      chomp @file_entries;
    } else {
      print STDERR "ERROR: specified entry list file \"",
        ${options}->{"entry-list"}, "\" does not exist\n",
          "or is not readable.\n";
      exit(1);
    }
  }
  foreach my $entry (@{${options}-> {"entries"}},
                     (${options}->{"all-entries"}?sort keys %{$optional_entries->{$module_type}}:()),
                     @file_entries) {
    if (not exists $entries_hash{$entry}) {
      push @entries, $entry;
      $entries_hash{$entry} = 1;
    } else {
      print STDERR "WARNING: Ignoring duplicate entry $entry\n";
    }
  }
  foreach my $entry (@entries) {
    if (exists ${optional_entries}->{${module_type}}->{${entry}}) {
      push @{$optional_ep_list},
        ${optional_entries}->{${module_type}}->{${entry}};
      printf $fh "${indent}%s;\n",
        ${optional_entries}->{${module_type}}->{${entry}};
      vprint "Adding optional member function ",
        ${optional_entries}->{${module_type}}->{${entry}},
          "\n";
    } elsif ($entry =~ m&\<.*\(&) {
      print STDERR "Listed private member function \"$entry\" is too complex to handle.\n",
        "Please add this to ${class_name} yourself after generation.\n";
      next;
    } else {
      vprint "Adding private member ",
        ($entry =~ m&\(\s*$&)?"function":"data",
        " $entry\n";
      push @{$unrecognized_entries}, "${entry}";
    }
  }
  print $fh "\nprivate:\n",
    map( { "${indent}${_};\n"; } grep m&\)\s*$&, @{$unrecognized_entries}),
      "\n",
        map( { "${indent}${_};\n"; } grep { not m&\)\s*$&; } @{$unrecognized_entries}),
          "${indent}// Declare member data here.\n",
          "\n};\n";
}

sub functions_first {
  my $a_func = $a =~ m&\)\s*$&;
  my $b_func = $b =~ m&\)\s*$&;
  if ($a_func and not $b_func) {
    return $a;
  } elsif ($b_func and not $a_func) {
    return $b;
  }
}

sub qualify_strip_func {
  my $func = shift;
  $func =~ s&^\s*\bvirtual\b\s*&&;
  $func =~ s&\s*\boverride\b\s*$&&;
  $func =~ s&([A-Za-z_0-9]+)(\s*(?:\(|$))&${qual_name}::${1}${2}&;
  return $func;
}

sub class_impl($\@\@) {
  my ($fh, $optional_ep_list, $unrecognized_entries) = @_;

  # Constructor and destructor.
  print $fh "${qual_name}::${class_name}(",
      join(", ", @{${constructors}->{${module_type}}->{args}}),
        ")\n";
  print $fh <<EOF;
// :
// Initialize member data here.
{
EOF

print $fh <<EOF if ($module_type eq "producer" or $module_type eq "filter");
${indent}// Call appropriate Produces<>() functions here.
EOF

print $fh <<EOF;
}

${qual_name}::~${class_name}()
{
${indent}// Clean up dynamic memory and other resources here.
}

EOF

  foreach my $req (sort keys %{${required_entries}->{${module_type}}}) {
    my $f = $required_entries->{${module_type}}->{${req}};
    print $fh
      qualify_strip_func($f),
        "\n{\n${indent}// Implementation of required member function here.\n}\n\n";
  }

  foreach my $entry (@{$optional_ep_list}) {
    my $f = $entry;
    print $fh
      qualify_strip_func($f),
        "\n{\n${indent}// Implementation of optional member function here.\n}\n\n";
  }

  foreach my $entry (grep m&\)\s*$&, @{$unrecognized_entries}) {
    my $f = $entry;
    print $fh
      qualify_strip_func($f),
        "\n{\n${indent}// Implementation of private member function here.\n}\n\n";
  }

}

sub module_reg {
  my $fh = shift;
  print $fh ${macros}->{${module_type}}, "($qual_name)\n";
}

sub vprint {
  print "INFO: ", @_ if ${options}->{verbose};
}

__END__

=pod

=head1 NAME

artmod: Generate clean module source for art.

=head1 SYNOPSIS

B<artmod> B<-h> | B<--help> | B<-?>

B<artmod> B<--help-types>

B<artmod> [I<optons>] [--] I<module-type> I<qualified-name>

I<Options>: B<--all-entries|-A> |
         B<--boilerplate|-b> I<file> |
         B<--entries|--entry|-e> I<entry>+ |
         B<--header-loc> I<path> |
         B<--split> |
         B<--split-ext> [I<lib-source-extension>] |
         B<--verbose|-v>

Options marked with B<+> are repeatable and cumulative.

=head1 DESCRIPTION

I<artmod> is a tool to produce an art module source skeleton for an
analyzer, a filter or a producer. The user can specify which optional
member functions are to be configured and whether to split the source
into three files or combine it into one. In addition, the name of a file
wherein boilerplate comments or code may be found for insertion into the
source may be specified.

=head2 HELP OPTIONS

=item B<--help>

This help.

=item B<--help-types>

Display each available module type, with required and optional interface.

=head2 ARGUMENTS

=over

=item I<module-type>

The type of the module to be generated. See the B<--help-types> option.

=item I<qualified-name>

The namespace-qualified class name (eg ns1::ns2::MyClass).

=back

=head2 OPTIONS

=over

=item B<--all-entries>

=item B<-A>

Include all optional entry points for the specified module type.

=item B<--boilerplate> I<file>

=item B<-b> I<file>

Include the specified file as preamble in all generated files.

Certain format strings will be honored, such as:

  %c  The class name
  %C  The qualified class name
  %d  The date and time of generation of the module.
  %f  The basename of the file in which the boilerplate is
        included.
  %F  The fully-qualified path of the file in which the
        boilerplate is included.
  %n  The qualification (namespace chain) of the class.
  %t  The type of module generated.
  %u  The login name of the invoker of artmod.
  %U  The full name (if available) if the invoker of artmod, or
        the login name if not.
  %v  The version of art from which the generation script came.

Literal % characters should be escaped (\%).

If the boilerplate file is not specified artmod will interrogate an
environment variable, "ARTMOD_BOILERPLATE" and attempt to include the
file specified. If that is also not found, artmod will use an internal
default.

See also B<--impl-boilerplate>, below.

=item B<--entry-list> I<file>

=item B<-E> I<file>

Specify a file containing a list, one per line, of desired member
functions or data for the class to be generated. This list will be OR-ed
with any specified on the command line (see -e, below)

=item B<--entries> I<entry>+

=item B<--entry> I<entry>+

=item B<-e> I<entry>+

Specify optional member functions or data. A recognized entry will be
put in with the correct siganture; a non-recognized entry (member
function, for example) will be put in the private section as either a
member function or member data depending on the presence of
parentheses. For example,

-e beginJob -e endJob -e reconfigure
-e "bool doPrivateStuff(T1 const &t1, T2 const &t2)"
-e "std::vector<int> privateData_"

=item B<--force>

=item B<-f>

Force overwrite of existing files; the default is to not overwrite.

=item B<guard> I<header-guard-spec>

The specification for the header guard. '%' format specifiers are
honored, as are the Perl-regex directives \U, \L and \E. Ignored unless
the --split option is used. The environment variable ARTMOD_HEADER_GUARD
will be interrogated in the absence of this option, and failing, that
the default will be the header file's path from package-top. See the
documentation for B<--boilerplate> above for information about
substitutions.

=item B<--header-loc> I<path>

The path part of the header include directive for the class definition
(eg art/Framework/Core). Ignored unless the --split option is used.

=item B<--impl-boilerplate> I<file>

Boilerplate specifically for placement prior to the implementation of
the module. In the separate-file mode of operation, the standard
boilerplate will be omitted from the implementation code.  The
environment variable ARTMOD_IMPL_BOILERPLATE will be interrogated in the
absence of this option. See the documentation for B<--boilerplate> above
for information about substitutions.

=item B<--split>

Produce three files: I<class-name>.h, <class-name>I<ext> and
I<class-name>_module.cc (note you must supply the period yourself). The
default behavior is to produce one file only:
I<class-name>_module.cc.

One complication of using this option is that, in order to properly
specify the header location (I<package>/[I<dir>]+) as required by the
implementation and module registration files, you will need to use the
B<--header-loc> option described above.

Before you use this item, note that there are several advantages to the
one-file philosophy in this case:

=over

=item 1.

The only communication with a module should be via the run, the subrun
and/or the event. Having the class definition in the same file as its
implmenetation helps enforce this.

=item 2.

When both the module implementation and the module macro invocation are
in the <name>_module.cc file, then the module library contains all the
module implementation code and its dependencies are separate from the
dependencies of code in the package's general code library. This makes
for easier maintenance of package dependencies.

The default value of I<ext> is ".cxx" unless changed with
B<--split-ext>, below.

=back

=item B<--split-ext> I<ext>

Change the extension of the class implemenation file from .cxx to
I<ext>. Specifying this option automatically implies --split.

=item B<--verbose>

=item B<-v>

Print some extra messages about functions generated, etc.

=back

=cut
