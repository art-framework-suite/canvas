===========================================
Design Notes for Module and Service Plugins
===========================================

Modules are EDProducers, EDFilters, EDAnalyzers, OutputModules and
Sources. 

**NOTE**: we may be moving to a very different i/o system, that will
make much of the current OutputModules and Sources irrelevant.

When the framework executable starts up, the class names for the
modules and services to be loaded are obtained from the configuration.
A module *Factory* is used to create the modules.

Factory
=======

For a given module, the configuration will announce:

1. what type of module it is (EDProducer, EDFilter, ...)
2. what the name of the class is (IntProducer); 
   the class name lacks all namespace qualification

The framework calls upon a *Factory* singleton instance to create an
instance of the correct class::

   auto_ptr<EDProducer> Factory::makeEDProducer(string const& typespec,
                                                ParameterSet const& config);
   auto_ptr<EDFilter> Factory::makeEDFilter(string const& typespec,
                                            ParameterSet const& config);
   ...


The string *typespec* is the string provided in the user's
configuration of the framework. It determines the concrete module class to be
instantiated, and can appear in two forms:

# Long form *typespec*, like "test/Framework/Core/stubs/IntProducer".

# Short form *typespec*, like "IntProducer"

The *Factory* is responsible for

0. Accepting registration of *factory functions*, given a short form
   and long form name associated with the *factory function*.

1. Mapping the given *typespec* to the appropriate *factory function*,
   or throwing an informative exception if the mapping is either ambiguous
   or no matching function can be found.

2. Invoking the the *factory function* to create and return the requested
   module.

It is possible for a short form *typespec* to map to more than one long form;
an exception should be thrown only if an ambiguous lookup is attempted.

It is an error to register more than one *factory function* for any
long form name; the attempt to do so should result in an informative
exception being thrown.

Before it is used to create modules,
the *Factory* must be loaded with the appropriate *factory* *functions*.
This is done with the help of the *PluginManager*.

PluginManager
=============

The *PluginManager* is the class used to load dynamic libraries
containing the implementation of modules.

The *PluginManager* is responsible for scanning parts of the file system
to find all dynamic libraries with the appropriate form name, matching
the file glob "\*_plugin.<suffix>", where <suffix> is the suffix used to
identify dynamic libraries on the system in question.

The *PluginManager* should be provided with the name of a directory to
scan, and should pick up all the plugins in that directory. It is the
responsibility of the user of the *PluginManager* (e.g. the *Factory*)
to direct the *PluginManager* to scan more than one directory, if more
than one directory needs to be scanned.

The *PluginManager* loads all the plugins it finds (using *dlopen*),
and provides access to plugins by "short name" and "long name" (see above).
A plugin with filename ``a/b/c/lib_d_plugin.<suffix>`` is associated with the
long form name ``a/b/c/d`` and with the short form name ``d``.

The *PluginManager* is responsible for giving access to any symbol in
a loaded library, given the (long or short form) name of the library
and the name of the symbol. The symbol is returned as a ``void*``, and
it is up to the user of the symbol to understand what the underlying
type really is.

The *PluginManager* should not provide any facility for unloading
libraries, which is not safe in a C++ program.

Plugins
=======

Each module class must be defined in its own dynamic library, which
must be named ``lib_<module>_plugin.<suffix>``, where *<suffix>* is
whatever is appropriate for the platform; these are called *plugin*
libraries.

Plugin libraries are loaded by the plugin manager; see above.

The source file in which a module is implemented must be named
``<module>_plugin.cc``. It must contain an invocation of the
*DEFINE_EDM_PLUGIN* macro.

The *DEFINE_EDM_PLUGIN* macro is responsible for writing the
appropriate *factory* *function*. We may need to have more fine-grained
macros, one for each type of module to be created:
*DEFINE_EDPRODUCER*, etc.

FactoryFunctions
================

The *factory* *function* is an ``extern "C"`` function with a given
name, and that takes a const reference to a *ParameterSet* and that
returns a newly-created instance of the associated module type,
initialized with the given *ParameterSet*, and wrapped in a smart
pointer to the appropriate module base class (e.g. *EDProducer*,
*EDFilter*, etc.).


