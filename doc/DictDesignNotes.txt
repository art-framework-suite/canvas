
What shall we do about the dictionary loading feature of the plugin manager?

Currently a build of a Toy data product produces three shared objects:

 * libToy_dict_plugin.so : reflex ROOT dictionaries for a set of classes
 * libToy_map_plugin.so : contains the names of classes defined in _dict.so file
 * libToy.so : the user portion of the code

The *_map* files contain a symbol called "SEAL_CAPABILITIES".
This symmbol is a function with the signature void () (const char **&, int&).
So it returns a list of c-style strings and the count of how many there are.
The names come in with the prefix "LCGReflex/".


We propose to leave the files that are currently made (dict, map, userlib)
and retain the product name embedded within the full library name (Toy in the
above example).  

The procedure for using these product files is an follows.
 1. obtain list of all map files using all paths defined in LD_LIBRARY_PATH
 2. for each map file in the list:
 3.		dlopen it
 4.		locate SEAL_CAPABILITIES function and obtain class name list
 5. 	for each class name in class name list
 6. 		remove the LCGReflex prefix
 7.			save the name and reference to the library it comes from (dict)
 8.		end
 9.	end
 
The LoadAllDictionaries will need to be further inspected to make

-----------

The function "string map_to_dict(libname)" changes the _map file name to the
_dict file name.

The function "void get_map_list(vector<string>&)" will find all the 
_map files in the file system.

PluginCapabilities::tryToFind(libname) makes use of the SEAL_CAPABILITIES
symbol to extract the class names.

------------

Here are many of the uses of the plugin manager interface.  The
most relevant for the dictionary plugins are the RootAutoLibraryLoader
and LoadAllDictionaries.

RootAutoLibraryLoader :
	PluginCapabilities -> load(classname),
	PluginCapabilities -> tryToLoad(name),
	CategoryToInfos
	
LoadAllDictionaries :
	Infos, CateogryToInfos
	PluginCapabilities -> load(classname)
	
VectorInputSourceFactory :
	PluginFactory<ISVecFunc>
	
Core/InputSourceFactory :
	PluginFactory<ISFunc>
	
ServicePluginFactory : 
	PluginFactory< ServiceMakerBase* ()>
	
Code/Factory :
	PluginFactory<Maker*>
	
PluginManager / SharedLibrary : needs to stay
PluginManager / PresenceFactory : special typedef using abstract class

---------------

Three interesting functions:



bool
  PluginCapabilities::tryToFind(const SharedLibrary& lib)
  {
    string name = map_to_dict(lib.path().native_file_string());

    FDEBUG(3) << "cap::tryToFind " << name << "\n";

    typedef void (*CapFunc)(const char **&, int&);
    const char** names;
    int size;
    const char* cap = "SEAL_CAPABILITIES";
    void* sym;
    CapFunc func;

    if(! lib.symbol(cap,sym)) return false;
    func=(CapFunc)sym;

    func(names, size);
    PluginInfo info;

    FDEBUG(3) << "cap: got " << size << " names from lib\n";

    for(int i=0;i<size;++i)
      {
        FDEBUG(5) << "  class name: " << name
                  << " : " << names[i] << "\n";
        // make class_name -> library_name mapping
        classes_[names[i]] = name;

        // announce to world that it is here!
        info.name_ = names[i];
        info.loadable_ = lib.path();
        this->newPluginAdded_(category(),info);
      }
    return true;
  }

  std::string map_to_dict(const string& libname)
  {
    string map_name(libname);
    string sub("_map_");
    size_t found = map_name.find(sub);
    if(found==string::npos)
      {
        FDEBUG(1) << "Could not find _map_ file for " << map_name << "\n";
        throw artZ::Exception("NoMatch") << "could not find _dict_ library for "
                                      << libname << "\n";
      }
    string name(map_name.substr(0,found)+"_dict_plugin.so");
    return name;
  }

namespace plugin
{
  void get_map_list(vector<string>& result)
  {
    // load all the _map_ files now
    // JBK - hack for now - just look in one fixed spot for the
    // *_map_*.so files
    // This code really needs to go through every path in
    // LD_LIBRARY_PATH and find all the *_map_*.so files

    // This code fails if a non-existent directory is in LD_LIBRARY_PATH

    // we expect that the base library directory will be in LD_LIBRARY_PATH
    const char* ldlib_env = getenv("LD_LIBRARY_PATH");
    // right now, FW_HOME points to the source code directory,
    // which is not where cmake installs libraries
    // also, FW_HOME was not used in this code
    //const char* home_env = getenv("FW_HOME");
    // LOCAL_PLUGIN_DIR is the test library directory
    // this environmental variable may not exist
    const char* plug_env = getenv("LOCAL_PLUGIN_DIR");

    //if(!home_env)
    //  {
        //throw artZ::Exception("env missing")
        //  << "cannot find environment variable FW_HOME\n";
    //  }
    if(!ldlib_env)
      {
        throw artZ::Exception("env missing")
          << "cannot find environment variable LD_LIBRARY_PATH\n";
      }

    string ldlib_str = ldlib_env;
    char tmp_str[500];
    istringstream ist(ldlib_str);
    typedef vector<string> strings;
    strings paths;
    bool stop=false;

    if(plug_env) {
        paths.push_back(std::string(plug_env));
      }
    while(!stop)
      {
        ist.getline(&tmp_str[0],sizeof(tmp_str),':');
        if(ist.eof()) stop=true;
        paths.push_back(tmp_str);
      }

    regex libpattern(".*_map_plugin.so$");
    for(strings::iterator cur(paths.begin()),end(paths.end());cur!=end;++cur)
      {
        //ostringstream ost;
        //ost << *cur << "/tmp/lib";
        path full_path( *cur );
        for (directory_iterator
               i = directory_iterator(full_path),
               e = directory_iterator();
             i != e;
             ++i)
          {
            string filename(i->path().leaf());
            if (regex_match(filename, libpattern)) result.push_back(filename);
          }
      }
  }
}

